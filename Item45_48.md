## Item 45. 스트림은 주의해서 사용해라

``` Java
int squareSum = IntStream.range(1, 100)
        .map(x -> x * x)
        .reduce((x1, x2) -> x1 + x2)
        .getAsInt();
```

- 스트림은 **데이터 원소의 유/무한 시퀀스** 를 뜻함.
- soruce stream 부터 terminal operation 까지의 과정이라고 생각하면 된다.
- lazy evaluation 구조이고, 실제 evaluation 은 'terminal operation' 시범에 이루어진다.
- 즉 terminal operation 이 없는 stream 은 no-op 와 동일하다.
- fluent API 구조를 띈다.
- **잘못 쓰면 유지보수성을 오히려 해친다**

### 스트림의 예시
- Iterative 방법 
``` Java
// Prints all large anagram groups in a dictionary iteratively (Page 204)
public class IterativeAnagrams {
    public static void main(String[] args) throws IOException {
        File dictionary = new File(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();
                groups.computeIfAbsent(alphabetize(word), // groups 에 키가 없을 때에만, 초기 treeset 생성
                        (unused) -> new TreeSet<>()).add(word);
            }
        }

        for (Set<String> group : groups.values())
            if (group.size() >= minGroupSize)
                System.out.println(group.size() + ": " + group);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```
 - computeIfAbsent : jdk 의 interface default 활용의 예
``` Java
   default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }

        return v;
    }
```

- Stream 활용 예
``` Java
// Overuse of streams - don't do this! (page 205)
public static void main(String[] args) throws IOException {
    Path dictionary = Paths.get(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream<String> words = Files.lines(dictionary)) {
        words.collect(
                groupingBy(word -> word.chars().sorted()
                        .collect(StringBuilder::new,
                                (sb, c) -> sb.append((char) c),
                                StringBuilder::append).toString()))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .map(group -> group.size() + ": " + group)
                .forEach(System.out::println);
    }
}

// Tasteful use of streams enhances clarity and conciseness (Page 205)
// alphabetize 의 분리, map 을 활용하던 출력전용 부분을 forEach 로 이동
public static void main(String[] args) throws IOException {
    Path dictionary = Paths.get(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream<String> words = Files.lines(dictionary)) {
        words.collect(groupingBy(word -> alphabetize(word)))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .forEach(group -> System.out.println(group.size() + ": " + group)); 
    }
    ...
}

```

- stream 사용시 lambda 를 자연스럽게 활용하게 되는데, 변수명은 최대한 구체적으로 지정하여 코드 가독성에 도움을 줄 수 있다. (variable type 이 눈에 안보이기때문)

- char 자료형의 stream representation 의 문제점
``` Java
// Does not produce the expected result
// String 의 chars 는 IntStream 반환함.
"Hello world!".chars().forEach(System.out::print); // 721011081081113211911111410810033
System.out.println();

"Hello world!".chars().forEach(x -> System.out.print(x + " ")); // 72 101 108 108 111 32 119 111 114 108 100 33 
System.out.println();

// Fixes the problem
"Hello world!".chars().forEach(x -> System.out.print((char) x)); // Hello world!
System.out.println();
```

### code block 에서 가능하나 stream 내부에서는 불가능한 것
- 지역 변수 수정이 불가능, final 이거나 사실상의 final 인 경우만 읽을 수 있다.
- **loop 시 활용되는 return. break, continue 등의 flow control 을 할 수 없다.**

- **기존 코드의 stream 변환시, 새 코드가 더 나아 보일 때에만 적용하자**

## Item 46. 스트림에서는 부작용 없는 함수를 사용하라


## Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다


## Item 48. 스트림 병렬화는 주의하여 사용하라

## 부록
### Intellij Stream Debugger
- https://plugins.jetbrains.com/plugin/9696-java-stream-debugger
- https://www.youtube.com/watch?v=YW43GXmfQ3U
