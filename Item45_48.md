## Item 45. 스트림은 주의해서 사용해라

- 스트림은 **데이터 원소의 유/무한 시퀀스** 를 뜻함
- soruce stream 부터 terminal operation 까지의 과정이라고 생각하면 됨

``` Java
int squareSum = IntStream.range(1, 100)
        .map(x -> x * x)
        .reduce((x1, x2) -> x1 + x2)
        .getAsInt();
```

- Iterative 방법 
``` Java
// Prints all large anagram groups in a dictionary iteratively (Page 204)
public class IterativeAnagrams {
    public static void main(String[] args) throws IOException {
        File dictionary = new File(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();
                groups.computeIfAbsent(alphabetize(word), // groups 에 키가 없을 때에만, 초기 treeset 생성
                        (unused) -> new TreeSet<>()).add(word);
            }
        }

        for (Set<String> group : groups.values())
            if (group.size() >= minGroupSize)
                System.out.println(group.size() + ": " + group);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```
 - computeIfAbsent : jdk 의 interface default 활용의 예
``` Java
   default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }

        return v;
    }
```

- Stream 활용 예
``` Java
// Overuse of streams - don't do this! (page 205)
public static void main(String[] args) throws IOException {
    Path dictionary = Paths.get(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream<String> words = Files.lines(dictionary)) {
        words.collect(
                groupingBy(word -> word.chars().sorted()
                        .collect(StringBuilder::new,
                                (sb, c) -> sb.append((char) c),
                                StringBuilder::append).toString()))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .map(group -> group.size() + ": " + group)
                .forEach(System.out::println);
    }
}

// Tasteful use of streams enhances clarity and conciseness (Page 205)
// alphabetize 의 분리
public static void main(String[] args) throws IOException {
    Path dictionary = Paths.get(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream<String> words = Files.lines(dictionary)) {
        words.collect(groupingBy(word -> alphabetize(word)))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .forEach(g -> System.out.println(g.size() + ": " + g));
    }
}

```


## Item 46. 스트림에서는 부작용 없는 함수를 사용하라


## Item 47. 반환 타입으로는 스트림보다 컬렉션이 낫다


## Item 48. 스트림 병렬화는 주의하여 사용하라
